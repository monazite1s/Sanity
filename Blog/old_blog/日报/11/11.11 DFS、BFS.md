1. 数独
2. n皇后：先行后列放置
3. DFS的排列组合问题
   1. 组合需要去重，可以在递归中传入i+1作为下一次循环的start防止重复
   2. 连续相同可以使用used进行判断
   3. 间隔相同可以使用visited





TODO:

1. DFS岛屿问题





输出：

非常好 👍 马荣臻，我们来系统整理一份 **DFS 常见剪枝方式总表**。
 这个表不仅包含了“**剪枝类型 / 核心思想 / 常见变量 / 示例 / 适用场景**”，还总结了“**是否与搜索树层次有关**”等维度，让你在写题时能迅速定位该用哪种剪枝。

------

## 🧩 DFS 剪枝优化方式总览表

| 剪枝类型                                  | 核心思想                                        | 常见参数 / 变量                                              | 是否与层级有关 | 典型示例                                         | 适用场景                                         | 关键点 / 注意事项                                            |
| ----------------------------------------- | ----------------------------------------------- | ------------------------------------------------------------ | -------------- | ------------------------------------------------ | ------------------------------------------------ | ------------------------------------------------------------ |
| **① 起点剪枝（start 控制）**              | 每层递归从 `start` 位置开始，防止重复选择或倒退 | `dfs(start)`、`for (let i = start; i < n; i++)`              | ✅ 有关         | 组合、子集问题（如 LeetCode 77. 组合、78. 子集） | **组合问题**、**子集问题**、**非重复选择类搜索** | start 控制本层循环起点，使后续搜索只向前延伸，避免 `[1,2]` 与 `[2,1]` 重复 |
| **② used 数组剪枝**                       | 标记全局使用状态，防止同一个元素被重复使用      | `used[i] = true / false`                                     | ❌ 无关         | 46. 全排列、47. 全排列 II                        | **排列问题**、**路径遍历（节点唯一）**           | 适用于「每次都可从任意位置选取未使用元素」的场景             |
| **③ visited 数组 / 集合剪枝（同层去重）** | 每层使用一个局部集合，防止同层选取重复值        | `const visited = new Set()`                                  | ✅ 有关         | 491. 非递减子序列                                | **含重复元素的子序列 / 组合类问题**              | 与 used 区分：`visited` 是「同层局部」控制，`used` 是「全局」控制 |
| **④ 排序 + 相邻相同跳过剪枝**             | 排序后在循环中跳过相同值，减少重复分支          | `if (i > 0 && nums[i] === nums[i-1] && !used[i-1]) continue;` | ✅ 有关         | 47. 全排列 II、40. 组合总和 II                   | **含重复元素的排列 / 组合问题**                  | 依赖排序后保证相同元素相邻，通过 “未使用前一个相同元素” 控制分支顺序 |
| **⑤ 边界条件剪枝**                        | 提前排除不可能成功的路径，减少搜索空间          | `if (sum > target) return;`、`if (remain < 0) return;`       | ❌ 无关         | 39. 组合总和、216. 组合总和 III                  | **目标和 / 约束搜索问题**                        | 一般放在循环前或进入递归前，防止无意义搜索                   |
| **⑥ 剪除非最优路径（最优性剪枝）**        | 如果当前路径代价已劣于当前最优结果，则终止      | `if (curCost >= best) return;`                               | ❌ 无关         | 最短路径、旅行商问题、回溯优化问题               | **最短路径、最小代价搜索、回溯优化问题**         | 常与全局变量 `best` 或 DP 结合，属于“带目标优化”的剪枝       |
| **⑦ 状态压缩剪枝**                        | 用位掩码代替数组标记访问状态，提高效率          | `mask & (1 << i)`、`mask(1 << i)`                            | ❌ 无关         | N 皇后、状态压缩 DP                              | **N 皇后**、**状压 DP**、**节点状态标记类问题**  |                                                              |
| **⑧ 空间剪枝**                            | 避免深拷贝或无用的 path 复制，减少内存占用      | 原地修改 + 回溯：`path.push(); dfs(); path.pop();`           | ❌ 无关         | 几乎所有回溯题                                   | **通用回溯问题**                                 | 关键是“修改 → 递归 → 撤销”，不要新建数组                     |
| **⑨ 搜索顺序剪枝**                        | 对搜索顺序排序或优先挑选更可能成功的分支        | 排序 + 提前判断                                              | ✅ 有关         | 八皇后、数独、背包搜索                           | **搜索空间庞大、分支质量差异大**                 | 优先走“更可能可行”的路径，常结合启发式规则（例如最少可选点优先） |

------

## 🌱 特别对比：`used` vs `visited`

| 特征     | used                    | visited                       |
| -------- | ----------------------- | ----------------------------- |
| 作用范围 | **全局状态**（跨层）    | **单层状态**（当前递归层）    |
| 类型     | `boolean[]` 数组        | `Set()` 集合                  |
| 重复控制 | 防止同一元素被多次使用  | 防止同层相同数值重复分支      |
| 使用场景 | **排列类**（如 46, 47） | **组合 / 子序列类**（如 491） |
| 示例     | 47. 全排列 II           | 491. 非递减子序列             |

------

## 🎯 快速选择策略（总结口诀）

| 题型                 | 应用剪枝                             |
| -------------------- | ------------------------------------ |
| 组合、子集问题       | ✅ 使用 `start` 控制起点              |
| 含重复元素           | ✅ 排序 + `visited` 或 “相邻相同跳过” |
| 排列问题             | ✅ 使用 `used` 全局标记               |
| 目标和、路径约束     | ✅ 提前判断边界条件                   |
| 状压 DP / 皇后问题   | ✅ 位掩码优化状态                     |
| 优化搜索（最短路径） | ✅ 剪除非最优路径                     |
| 大规模深搜           | ✅ 优化顺序 + 空间剪枝                |

------

是否希望我接下来帮你把这个表格转成一份「面试速记版 PDF」（带颜色高亮 + 示例代码块）？
 那样你能在 iPad 上随时翻阅使用，复习非常方便。