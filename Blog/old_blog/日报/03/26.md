# React生命周期

> 在 React 18 之后，React 的主流开发模式由类组件转向了函数组件。类组件使用 `this.state`、`this.setState` 以及各种生命周期方法来管理组件状态，但它存在一些缺点，例如：
>
> - `this` 绑定问题，使得方法调用变得繁琐；
> - 状态逻辑分散，不易复用；
> - 严格分阶段执行，缺乏灵活性。
>
> 而函数组件通过 Hooks 提供更细粒度的控制，支持 React 并发模式，且更加轻量。尽管函数组件在许多场景下更优，但为了深入了解 React，我们还是来详细了解一下 React 的生命周期。

有一个非常好的网站，很详细地描绘了生命周期中的各个阶段：

[React lifecycle methods diagram](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

![image-20250326233645824](https://typora-image-mrz.oss-cn-beijing.aliyuncs.com/image-20250326233645824.png)

从单个组件的角度而言，生命周期可以分为挂载，更新，卸载三种

而从React整体架构而言，生命周期可以分为 Render、 Pre-commit、 Commit三个阶段

# 组件视角

首先从组件视角来看，我们对这些生命周期阶段进行一些了解

React 组件的生命周期是指组件从 **创建** → **更新** → **销毁** 这一完整的过程。

1. **挂载（Mounting）**：组件被创建并插入到 DOM 中。
2. **更新（Updating）**：组件的 `state` 或 `props` 发生变化，触发重新渲染。
3. **卸载（Unmounting）**：组件从 DOM 中移除。

| 生命周期方法                      | 阶段        | 作用                                        |
| --------------------------------- | ----------- | ------------------------------------------- |
| `constructor`                     | 挂载        | 初始化 state，绑定方法                      |
| `static getDerivedStateFromProps` | 挂载 & 更新 | 从 `props` 计算 `state`（很少使用）         |
| `render`                          | 挂载 & 更新 | 生成虚拟 DOM（VDOM），是唯一必须的方法      |
| `componentDidMount`               | 挂载        | 组件挂载后，适合进行 **数据请求、DOM 操作** |
| `shouldComponentUpdate`           | 更新        | 控制是否重新渲染（优化性能）                |
| `getSnapshotBeforeUpdate`         | 更新        | 组件更新前获取快照（用于 DOM 操作）         |
| `componentDidUpdate`              | 更新        | 组件更新后，适合进行 **DOM 操作、网络请求** |
| `componentWillUnmount`            | 卸载        | 组件销毁前，适合进行 **清理工作**           |

## 挂载阶段

**执行顺序：** `constructor` → `static getDerivedStateFromProps` → `render` → `componentDidMount`

### constructor

- 初始化 `state`，进行方法绑定。
- 不应该在 `constructor` 中执行副作用（如网络请求）。

### getDerivedStateFromProps

```js
static getDerivedStateFromProps(nextProps, prevState) {
  if (nextProps.value !== prevState.value) {
    return { value: nextProps.value };
  }
  return null;
}
```

- 作用：根据 `props` 计算 `state`（通常不推荐使用）。
- 特点：
  - 是 **静态方法**，无法访问 `this`。
  - 返回 `null` 代表 `state` 不变。
  - 不能调用 `setState`。

### render

- 生成虚拟 DOM。
- 必须是 **纯函数**，不能修改 `state`，不能执行副作用。

### componentDidMount

- 适合执行 **网络请求、订阅、操作 DOM**。
- **只执行一次**。
- 可以调用 `setState`（但要注意避免不必要的重新渲染）。

## 更新阶段

`setState`、`forceUpdate`、新的 `props`都可以触发更新

**执行顺序：** `static getDerivedStateFromProps` → `shouldComponentUpdate` → `render` → `getSnapshotBeforeUpdate` → `componentDidUpdate`

### shouldComponentUpdate

```js
shouldComponentUpdate(nextProps, nextState) {
  return nextProps.value !== this.props.value;
}
```

- 决定组件是否重新渲染，可以用来性能优化，避免不必要的更新
- **返回值**：
  - `true`（默认）→ 允许重新渲染。
  - `false` → 阻止 `render` 执行（但 `componentDidUpdate` 仍然会运行）。

### render

- 生成新的虚拟 DOM

### getSnapshotBeforeUpdate

```js
getSnapshotBeforeUpdate(prevProps, prevState) {
  if (prevProps.list.length < this.props.list.length) {
    return this.listRef.scrollHeight;
  }
  return null;
}
```

- **作用**：组件更新前获取快照（**适用于 DOM 操作**）
- **返回值**：返回值会作为 `componentDidUpdate` 的 `snapshot` 参数

### componentDidUpdate

```js
componentDidUpdate(prevProps, prevState, snapshot) {
  if (prevProps.id !== this.props.id) {
    this.fetchData();
  }
}
```

- **组件更新后执行副作用**（网络请求、DOM 操作）
- **可以调用 `setState`**（必须加条件判断，否则会死循环）

## 卸载阶段

**执行顺序：** `componentWillUnmount`

### componentWillUnmount

```js
componentWillUnmount() {
  clearInterval(this.timer);
}
```

- **作用**：
  - **清理副作用**（清除定时器、取消网络请求、取消订阅）

- **注意**：
  - **不能调用 `setState`**（组件即将销毁，没必要更新）

## 函数式组件模拟生命周期

函数组件可以使用hooks进行生命周期的模拟

| 生命周期               | Hooks 方案                                 |
| ---------------------- | ------------------------------------------ |
| `componentDidMount`    | `useEffect(() => {}, [])`                  |
| `componentDidUpdate`   | `useEffect(() => {}, [state])`             |
| `componentWillUnmount` | `useEffect(() => { return () => {} }, [])` |

# React整体视角

## 关于更新流程

React 的生命周期函数并不是在 **"组件的某个时刻"** 直接被触发的，而是由 **协调器（Reconciler）** 和 **渲染器（Renderer）** 共同控制的。

React 采用 **Fiber 架构** 来管理组件更新，整个更新流程基于 **双缓冲机制**，即 `current` 树 和 `workInProgress` 树 交替使用，以提高性能并支持中断更新。

1. 在 React Fiber 中，组件的更新过程是 **可中断的**，并且不同的更新任务具有不同的优先级。这意味着低优先级的更新可能会被高优先级的任务打断，等到更紧急的任务完成后再恢复执行。
2. 由于更新可能被中断，React 将更新过程拆分为 **两大阶段**：**协调（Reconciliation）阶段** 和 **提交（Commit）阶段**。
3. **协调阶段（Reconciliation Phase）**：React 计算组件的变化，确定哪些 DOM 需要更新。在这个阶段，更新任务是 **可中断的**，以保证高优先级任务（如用户交互）能够更快响应。
4. **提交阶段（Commit Phase）**：当协调阶段完成后，React 会将计算出的更新应用到 DOM 中。这一阶段是 **同步执行** 的，不能被打断，以确保 UI 更新的一致性。

总结一下，React 生命周期可以分为 三个阶段：

- **构造（Render）阶段**：
  - 计算要更新的组件（可中断）。
  - 可执行 `constructor`、`getDerivedStateFromProps`、`render`。
- **调度（Reconciliation）阶段**：
  - 计算 DOM 变化，生成更新计划（可中断）。
  - 可执行 `shouldComponentUpdate`、`getSnapshotBeforeUpdate`。
- **提交（Commit）阶段**：
  - 统一执行 DOM 操作和副作用（同步执行，不可中断）。
  - 可执行 `componentDidMount`、`componentDidUpdate`、`componentWillUnmount`。